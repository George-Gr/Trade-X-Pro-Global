# RLS Policies Prevention Checklist

**Purpose:** Guide for future database schema development  
**Target Audience:** Backend developers, DBAs, architects  
**Created:** Jan 29, 2026  
**Version:** 1.0  

---

## Pre-Development Checklist

### Before Creating a New Table

**Step 1: Purpose Definition**
- [ ] Clearly define table purpose (user data, audit trail, reference data, etc.)
- [ ] Identify if table contains user data (user_id), financial data, or sensitive info
- [ ] Determine access patterns (user-owned, admin-only, public, system-only)

**Step 2: Data Classification**
- [ ] **User-Owned Data** - Contains user_id, users should access own rows only
  - Examples: profiles, orders, positions, kyc_documents
  - Action: Plan user_id filtering + potential admin view-all access
  
- [ ] **Financial Data** - Contains balance, equity, amounts, fees
  - Examples: profiles (balance column), ledger, fills
  - Action: Plan edge-function-only writes, user read-only access
  
- [ ] **Audit Trail** - Contains security events, compliance records
  - Examples: audit_logs, admin_audit_log, withdrawal_audit
  - Action: Plan immutable (no UPDATE/DELETE), admin-only read, edge-function write
  
- [ ] **System Data** - Generated by system/edge functions, users cannot touch
  - Examples: daily_pnl_tracking, margin_call_events, liquidation_events
  - Action: Plan INSERT/UPDATE/DELETE blocked (false), read-only SELECT
  
- [ ] **Reference Data** - Public market data, lookup tables
  - Examples: asset_specs
  - Action: Plan public SELECT, no user writes

**Step 3: Table Design**
- [ ] Include appropriate columns (user_id for user-owned, timestamps, etc.)
- [ ] Design indexes for likely query patterns
- [ ] Plan any foreign key relationships

---

## During Table Creation (SQL Migration)

### Template: Secure Table Creation

```sql
-- ============================
-- NEW TABLE CREATION TEMPLATE
-- ============================

-- 1. CREATE TABLE with appropriate columns
CREATE TABLE public.table_name (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,  -- If user-owned
    -- Other columns...
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE (user_id, identifier)  -- If appropriate
);

-- 2. CRITICAL: Enable RLS immediately after table creation
ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;

-- 3. CREATE POLICIES based on table type
-- See "Policy Templates by Table Type" section below

-- 4. CREATE INDEXES for performance
CREATE INDEX idx_table_name_user_id ON public.table_name(user_id);
CREATE INDEX idx_table_name_created ON public.table_name(created_at DESC);
```

### Mandatory Checklist for Every New Table

**During Creation:**
- [ ] Table created with descriptive name (snake_case, lowercase)
- [ ] Appropriate columns defined (user_id for user data, created_at, etc.)
- [ ] PRIMARY KEY defined (UUID recommended)
- [ ] Foreign keys to auth.users or public.profiles with ON DELETE CASCADE
- [ ] CHECK constraints for data validation (balance >= 0, etc.)
- [ ] GENERATED columns for computed values (if needed)

**After Creation:**
- [ ] ✅ `ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;` - CRITICAL!
- [ ] CREATE at least 1 RLS policy (don't leave tables unprotected)
- [ ] CREATE index for user_id (if present)
- [ ] CREATE index for any frequently queried columns
- [ ] Document policy strategy in comments

**Before Committing:**
- [ ] Run `npm run supabase:pull` to regenerate types
- [ ] Run `npm run type:check` - 0 errors
- [ ] Write unit tests for policies
- [ ] Run tests: `npm run test`
- [ ] Verify table appears in types/database.ts

---

## Policy Templates by Table Type

### Template Type 1: User-Owned Data

**Use For:** User profiles, preferences, settings, user-generated content  
**Examples:** profiles (non-financial), kyc_documents, watchlists, order_templates, notification_preferences

```sql
-- Allow users to view their own records
CREATE POLICY "Users can view own [table]" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);

-- Allow users to insert their own records
CREATE POLICY "Users can insert own [table]" ON public.table_name
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Allow users to update their own records
CREATE POLICY "Users can update own [table]" ON public.table_name
    FOR UPDATE USING (auth.uid() = user_id);

-- Allow users to delete their own records
CREATE POLICY "Users can delete own [table]" ON public.table_name
    FOR DELETE USING (auth.uid() = user_id);

-- Allow admins to view all records
CREATE POLICY "Admins can view all [table]" ON public.table_name
    FOR SELECT USING (public.has_role(auth.uid(), 'admin'));

-- Optional: Allow admins to update all records
CREATE POLICY "Admins can update all [table]" ON public.table_name
    FOR UPDATE USING (public.has_role(auth.uid(), 'admin'));
```

**Checklist:**
- [ ] At least 2 policies created (SELECT + at least one write operation)
- [ ] User policies filter by `auth.uid() = user_id`
- [ ] Admin policies use `has_role(auth.uid(), 'admin')`
- [ ] INSERT uses `WITH CHECK` for validation
- [ ] UPDATE/DELETE use `USING` for row filtering

---

### Template Type 2: Edge-Function Protected (System Data)

**Use For:** Trading orders, positions, fills, ledger, any data managed by backend  
**Examples:** orders, positions, fills, ledger, position_lots, daily_pnl_tracking, margin_call_events

```sql
-- ✅ Users CAN read their own data
CREATE POLICY "Users can view own [table]" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);

-- ✅ Admins can view all data
CREATE POLICY "Admins can view all [table]" ON public.table_name
    FOR SELECT USING (public.has_role(auth.uid(), 'admin'));

-- ❌ Users CANNOT insert (edge function only)
CREATE POLICY "[table] created via edge functions only" ON public.table_name
    FOR INSERT WITH CHECK (false);

-- ❌ Users CANNOT update (edge function only)
CREATE POLICY "[table] cannot be modified by users" ON public.table_name
    FOR UPDATE USING (false);

-- ❌ Users CANNOT delete
CREATE POLICY "[table] cannot be deleted by users" ON public.table_name
    FOR DELETE USING (false);
```

**Checklist:**
- [ ] SELECT policies allow users to read own data
- [ ] INSERT policy: `WITH CHECK (false)` - blocks all users
- [ ] UPDATE policy: `USING (false)` - blocks all users
- [ ] DELETE policy: `USING (false)` - blocks all users
- [ ] Admin SELECT policy included for auditing
- [ ] Corresponding edge function implements actual writes

---

### Template Type 3: Admin-Only Immutable (Audit Trails)

**Use For:** Audit logs, compliance records, security events  
**Examples:** audit_logs, admin_audit_log, withdrawal_audit, balance_audit_log, margin_call_events_audit

```sql
-- ✅ Admins can read
CREATE POLICY "Admins can view [table]" ON public.table_name
    FOR SELECT USING (public.has_role(auth.uid(), 'admin'));

-- ❌ Nobody can insert (edge function only)
CREATE POLICY "[table] created via edge functions only" ON public.table_name
    FOR INSERT WITH CHECK (false);

-- ❌ Nobody can update (immutable)
CREATE POLICY "[table] cannot be modified" ON public.table_name
    FOR UPDATE USING (false);

-- ❌ Nobody can delete (immutable)
CREATE POLICY "[table] cannot be deleted" ON public.table_name
    FOR DELETE USING (false);
```

**Checklist:**
- [ ] Only admin SELECT access (users cannot view)
- [ ] All write operations blocked
- [ ] Edge function handles insertions
- [ ] No direct user access possible
- [ ] Properly documented as audit trail

---

### Template Type 4: Public/Reference Data

**Use For:** Market reference data, lookup tables  
**Examples:** asset_specs

```sql
-- ✅ Everyone can read (public)
CREATE POLICY "Anyone can view [table]" ON public.table_name
    FOR SELECT USING (true);

-- ❌ Nobody (users) can write
-- Note: No INSERT, UPDATE, DELETE policies needed - defaults to deny
```

**Checklist:**
- [ ] SELECT policy allows public access (`USING (true)`)
- [ ] No INSERT/UPDATE/DELETE by users
- [ ] Application layer controls write access (if needed)

---

### Template Type 5: Role-Based Filtering

**Use For:** User roles, permissions  
**Examples:** user_roles

```sql
-- Users can view their own role
CREATE POLICY "Users can view own role" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);

-- Admins can view all roles
CREATE POLICY "Admins can view all roles" ON public.table_name
    FOR SELECT USING (public.has_role(auth.uid(), 'admin'));

-- Prevent direct modification of roles (should use API endpoint)
-- Note: No INSERT, UPDATE, DELETE policies - defaults to deny
```

**Checklist:**
- [ ] Users can view own role only
- [ ] Admins can view all roles
- [ ] Direct role modifications blocked
- [ ] Role assignment handled via API endpoint

---

### Template Type 6: Trigger-Managed Auto-Creation

**Use For:** Tables where rows are auto-created (e.g., on signup)  
**Examples:** risk_settings

```sql
-- ✅ Users can read own records
CREATE POLICY "Users can view own [table]" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);

-- ✅ Users can update own records
CREATE POLICY "Users can update own [table]" ON public.table_name
    FOR UPDATE USING (auth.uid() = user_id);

-- ❌ Users CANNOT insert (trigger auto-creates on signup)
CREATE POLICY "[table] created via trigger only" ON public.table_name
    FOR INSERT USING (false);

-- ✅ Admins can view all
CREATE POLICY "Admins can view all [table]" ON public.table_name
    FOR SELECT USING (public.has_role(auth.uid(), 'admin'));
```

**Checklist:**
- [ ] INSERT blocked with `USING (false)` (trigger handles creation)
- [ ] SELECT allows user access to own + admin view all
- [ ] UPDATE allows users to modify own records
- [ ] Trigger function is properly defined and tested
- [ ] Trigger fires on correct event (e.g., after INSERT on auth.users)

---

## Post-Migration Verification

### Verification Checklist

After creating a new table, run these verification steps:

**Step 1: RLS Enabled Check**
```sql
-- Run this query to verify RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public'
AND tablename = 'your_table_name';
-- Should return: rowsecurity = true
```

**Step 2: Policy Verification**
```sql
-- View all policies on your table
SELECT * FROM pg_policies
WHERE tablename = 'your_table_name'
ORDER BY polname;
-- Should show at least 1 policy
```

**Step 3: Type Generation**
```bash
# Regenerate types after adding table
npm run supabase:pull

# Verify types were generated
npm run type:check
# Should show 0 errors
```

**Step 4: Test Policy Implementation**
```typescript
// Example test for user-owned data
import { supabase } from "@/integrations/supabase/client";

describe("TableName RLS Policies", () => {
  it("User should only see own records", async () => {
    const { data } = await supabase
      .from("table_name")
      .select("*");
    
    // Verify all returned records have user_id = auth.uid()
    expect(data.every(r => r.user_id === user.id)).toBe(true);
  });

  it("User should not be able to insert with different user_id", async () => {
    const { error } = await supabase
      .from("table_name")
      .insert({ user_id: "different-uuid", ...otherData });
    
    expect(error).toBeDefined(); // Should be rejected by RLS
  });
});
```

**Step 5: Code Review**
- [ ] Migration follows template structure
- [ ] RLS enabled immediately after CREATE TABLE
- [ ] Policies follow appropriate template type
- [ ] Policies have descriptive names (standard format)
- [ ] Admin access properly implemented (if needed)
- [ ] Tests written for policy behavior
- [ ] Comments document security decisions

---

## Policy Naming Convention

### Standard Format

```
[Action] [subject] [object]
↓        ↓         ↓
Users    can       view own [table]
Admins   can       manage   all [table]
Service  can       insert   [table]
```

### Examples

✅ **Correct Naming:**
- "Users can view own orders"
- "Admins can view all profiles"
- "Edge functions can update profiles"
- "Orders created via edge functions only"
- "Audit logs cannot be deleted"

❌ **Avoid These Names:**
- "select_policy" (not descriptive)
- "ordr1" (unclear)
- "x" (meaningless)

---

## Common Mistakes to Avoid

### ❌ Mistake 1: Forgetting to Enable RLS

```sql
-- WRONG - RLS not enabled!
CREATE TABLE public.user_data (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    data TEXT
);
-- Table is vulnerable!

-- CORRECT - RLS enabled immediately
CREATE TABLE public.user_data (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    data TEXT
);
ALTER TABLE public.user_data ENABLE ROW LEVEL SECURITY;
```

### ❌ Mistake 2: Policies Without RLS Enabled

```sql
-- WRONG - These policies won't work without RLS enabled!
ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;
-- Forgot to enable RLS first...

-- CORRECT - Enable RLS before creating policies
ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own data" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);
```

### ❌ Mistake 3: Using FALSE for User Access

```sql
-- WRONG - Blocks all users!
CREATE POLICY "Users can view data" ON public.table_name
    FOR SELECT USING (false);  -- This blocks everyone!

-- CORRECT - Use appropriate condition
CREATE POLICY "Users can view own data" ON public.table_name
    FOR SELECT USING (auth.uid() = user_id);
```

### ❌ Mistake 4: Forgetting Admin Access

```sql
-- WRONG - Admins can't see anything!
CREATE POLICY "Users can view own orders" ON public.orders
    FOR SELECT USING (auth.uid() = user_id);
-- What about admins auditing orders?

-- CORRECT - Include admin access
CREATE POLICY "Users can view own orders" ON public.orders
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admins can view all orders" ON public.orders
    FOR SELECT USING (public.has_role(auth.uid(), 'admin'));
```

### ❌ Mistake 5: Allowing User Writes to Financial Data

```sql
-- WRONG - Users can modify their own balance!
CREATE POLICY "Users can update profiles" ON public.profiles
    FOR UPDATE USING (auth.uid() = id);

-- CORRECT - Freeze financial columns
CREATE POLICY "Users can update non-financial profile data" ON public.profiles
    FOR UPDATE 
    USING (auth.uid() = id)
    WITH CHECK (
        auth.uid() = id AND
        balance = (SELECT balance FROM public.profiles WHERE id = auth.uid())
    );
```

### ❌ Mistake 6: Missing Edge-Function Protection

```sql
-- WRONG - Users can manipulate orders!
CREATE TABLE public.orders (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    status TEXT
);
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own orders" ON public.orders
    FOR SELECT USING (auth.uid() = user_id);
-- Users can still INSERT/UPDATE/DELETE!

-- CORRECT - Block user writes
CREATE POLICY "Orders cannot be modified by users" ON public.orders
    FOR UPDATE USING (false);
CREATE POLICY "Orders cannot be deleted by users" ON public.orders
    FOR DELETE USING (false);
```

---

## PR Checklist for Database Changes

Before submitting PR with database changes:

- [ ] **Schema Changes**
  - [ ] Migration file created in `supabase/migrations/`
  - [ ] File named with timestamp: `YYYYMMDDHHMMSS_description.sql`
  - [ ] All new tables have RLS enabled
  - [ ] All policies follow appropriate template

- [ ] **Security**
  - [ ] No financial data writable by users
  - [ ] All user-owned data filtered by user_id
  - [ ] Audit trails immutable
  - [ ] Admin access properly scoped
  - [ ] Edge-function control verified

- [ ] **Types & Documentation**
  - [ ] Run `npm run supabase:pull`
  - [ ] Types generated in `src/integrations/supabase/types.ts`
  - [ ] No type errors: `npm run type:check` passes
  - [ ] Policies documented in comments

- [ ] **Testing**
  - [ ] Tests written for RLS policies
  - [ ] All tests pass: `npm run test`
  - [ ] Policy behavior verified:
    - [ ] User isolation works
    - [ ] Admin access works
    - [ ] Write protection works

- [ ] **Code Review**
  - [ ] Migration reviewed by team lead
  - [ ] Security implications discussed
  - [ ] Performance impact considered
  - [ ] Future table creation use updated

- [ ] **CI/CD**
  - [ ] `npm run build:check` passes
  - [ ] No build size increases
  - [ ] No console warnings/errors

---

## Monthly Audit Procedure

### Every Month: Verify RLS Compliance

**First Monday of Month:**

1. **List All Tables**
   ```sql
   SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;
   ```

2. **Verify RLS Enabled**
   ```sql
   SELECT tablename, rowsecurity
   FROM pg_tables
   WHERE schemaname = 'public'
   AND rowsecurity = false;
   -- Should return 0 rows
   ```

3. **Check for Overly Permissive Policies**
   ```sql
   SELECT tablename, polname
   FROM pg_policies
   WHERE tablename LIKE 'public.%'
   AND poldef LIKE '%true%'  -- Check for USING (true) without owner check
   ORDER BY tablename;
   ```

4. **Review Recent Changes**
   - Check git log for recent migration files
   - Review PR comments for security discussions
   - Audit any new tables

5. **Test Sample Policies**
   - Pick 3 random user-owned tables
   - Verify users can't access other users' data
   - Verify admins can view all data
   - Verify edge functions can write

6. **Document Findings**
   - Create monthly audit report
   - Share with team
   - Address any issues found

---

## Resources

### Reference Files
- Core RLS baseline: `supabase/migrations/20251105143255_eafa25e6-2c40-4242-8a07-1e9713793f92.sql`
- Edge function protection: `supabase/migrations/20251110162318_08b084f9-b636-4640-b4b3-c2c333af73f3.sql`
- Admin audit logs: `supabase/migrations/20251110163327_543533f0-6dde-42df-acad-ac95303d7ea1.sql`

### Documentation
- Complete RLS audit matrix: `DAY_3-4_RLS_AUDIT_MATRIX.md`
- Table coverage report: `DAY_3-4_RLS_TABLE_COVERAGE.md`
- Security checklist: `SECURITY_CHECKLIST.md`

### Team Communication
- Slack channel: #database-security
- Monthly audit thread: See #database-security pinned messages
- Questions? Ask in #backend-dev

---

**Document Version:** 1.0  
**Last Updated:** Jan 29, 2026  
**Next Review:** Feb 29, 2026  
**Maintained By:** Security Team
