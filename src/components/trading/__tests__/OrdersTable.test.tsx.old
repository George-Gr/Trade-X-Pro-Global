import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { OrderStatusBadge, classifyOrderStatus, calculateFillPercentage, type OrderStatus } from '../OrderStatusBadge';
import { OrderRow, type Order } from '../OrderRow';
import { OrdersTable } from '../OrdersTable';

// ============================================================================
// OrderStatusBadge Tests
// ============================================================================

describe('OrderStatusBadge', () => {
  it('should render pending status with yellow color', () => {
    render(<OrderStatusBadge status="pending" />);
    const badge = screen.getByText('Pending');
    expect(badge).toBeInTheDocument();
    expect(badge.closest('[class*="bg-yellow"]')).toBeInTheDocument();
  });

  it('should render open status with blue color', () => {
    render(<OrderStatusBadge status="open" />);
    const badge = screen.getByText('Open');
    expect(badge).toBeInTheDocument();
    expect(badge.closest('[class*="bg-blue"]')).toBeInTheDocument();
  });

  it('should render filled status with green color', () => {
    render(<OrderStatusBadge status="filled" />);
    const badge = screen.getByText('Filled');
    expect(badge).toBeInTheDocument();
    expect(badge.closest('[class*="bg-green"]')).toBeInTheDocument();
  });

  it('should render cancelled status with gray color', () => {
    render(<OrderStatusBadge status="cancelled" />);
    const badge = screen.getByText('Cancelled');
    expect(badge).toBeInTheDocument();
    expect(badge.closest('[class*="bg-gray"]')).toBeInTheDocument();
  });

  it('should render rejected status with red color', () => {
    render(<OrderStatusBadge status="rejected" />);
    const badge = screen.getByText('Rejected');
    expect(badge).toBeInTheDocument();
    expect(badge.closest('[class*="bg-red"]')).toBeInTheDocument();
  });

  it('should display fill percentage for partially filled orders', () => {
    render(<OrderStatusBadge status="partially_filled" fillPercentage={50} />);
    expect(screen.getByText(/Partial \(50%\)/)).toBeInTheDocument();
  });

  it('should include timestamp in tooltip', () => {
    const timestamp = new Date('2025-11-14T10:00:00');
    render(<OrderStatusBadge status="open" timestamp={timestamp} />);
    const badge = screen.getByText('Open').closest('div');
    expect(badge).toHaveAttribute('title', expect.stringContaining('10:00:00'));
  });

  it('should render all status types without crashing', () => {
    const statuses: OrderStatus[] = [
      'pending',
      'open',
      'partially_filled',
      'filled',
      'cancelled',
      'rejected',
      'expired',
    ];

    statuses.forEach((status) => {
      const { unmount } = render(<OrderStatusBadge status={status} />);
      expect(screen.getByText(expect.stringMatching(new RegExp(status.split('_')[0], 'i')))).toBeInTheDocument();
      unmount();
    });
  });
});

// ============================================================================
// classifyOrderStatus Utility Tests
// ============================================================================

describe('classifyOrderStatus', () => {
  it('should return cancelled for cancelled orders', () => {
    const result = classifyOrderStatus({
      status: 'cancelled',
      filled_quantity: 0,
      quantity: 100,
    });
    expect(result).toBe('cancelled');
  });

  it('should return filled when all quantity filled', () => {
    const result = classifyOrderStatus({
      status: 'active',
      filled_quantity: 100,
      quantity: 100,
    });
    expect(result).toBe('filled');
  });

  it('should return partially_filled when some quantity filled', () => {
    const result = classifyOrderStatus({
      status: 'active',
      filled_quantity: 50,
      quantity: 100,
    });
    expect(result).toBe('partially_filled');
  });

  it('should return open for active orders with no fills', () => {
    const result = classifyOrderStatus({
      status: 'open',
      filled_quantity: 0,
      quantity: 100,
    });
    expect(result).toBe('open');
  });

  it('should return pending for pending orders', () => {
    const result = classifyOrderStatus({
      status: 'pending',
      filled_quantity: 0,
      quantity: 100,
    });
    expect(result).toBe('pending');
  });
});

// ============================================================================
// calculateFillPercentage Utility Tests
// ============================================================================

describe('calculateFillPercentage', () => {
  it('should return 0 for zero filled quantity', () => {
    expect(calculateFillPercentage(0, 100)).toBe(0);
  });

  it('should return 100 for fully filled', () => {
    expect(calculateFillPercentage(100, 100)).toBe(100);
  });

  it('should return 50 for 50% fill', () => {
    expect(calculateFillPercentage(50, 100)).toBe(50);
  });

  it('should round to nearest integer', () => {
    expect(calculateFillPercentage(33, 100)).toBe(33);
    expect(calculateFillPercentage(67, 100)).toBe(67);
  });

  it('should return 0 for zero total quantity', () => {
    expect(calculateFillPercentage(0, 0)).toBe(0);
  });
});

// ============================================================================
// OrderRow Tests
// ============================================================================

describe('OrderRow', () => {
  const mockOrder: Order = {
    id: 'order-123',
    symbol: 'EURUSD',
    type: 'limit',
    side: 'buy',
    quantity: 100,
    filled_quantity: 50,
    price: 1.0850,
    limit_price: 1.0850,
    status: 'partially_filled',
    created_at: new Date('2025-11-14T10:00:00'),
    updated_at: new Date('2025-11-14T10:30:00'),
    average_fill_price: 1.0845,
    commission: 10,
    slippage: 0.05,
  };

  it('should render order details', () => {
    render(<OrderRow order={mockOrder} />);
    expect(screen.getByText('EURUSD')).toBeInTheDocument();
    expect(screen.getByText(/Limit/)).toBeInTheDocument();
    expect(screen.getByText(/BUY/)).toBeInTheDocument();
  });

  it('should display filled/total quantity', () => {
    render(<OrderRow order={mockOrder} />);
    expect(screen.getByText('50 / 100')).toBeInTheDocument();
  });

  it('should show order ID and copy button', () => {
    render(<OrderRow order={mockOrder} />);
    expect(screen.getByText('order-123')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '' })).toBeInTheDocument(); // Copy button
  });

  it('should display commission and slippage', () => {
    render(<OrderRow order={mockOrder} />);
    expect(screen.getByText('Comm: $10.00')).toBeInTheDocument();
    expect(screen.getByText('Slip: 0.05%')).toBeInTheDocument();
  });

  it('should show average fill price when available', () => {
    render(<OrderRow order={mockOrder} />);
    expect(screen.getByText(/Filled @ 1.0845/)).toBeInTheDocument();
  });

  it('should display timestamps', () => {
    render(<OrderRow order={mockOrder} />);
    expect(screen.getByText(/Created:/)).toBeInTheDocument();
    expect(screen.getByText(/Updated:/)).toBeInTheDocument();
  });

  it('should call onModify when modify action clicked', async () => {
    const user = userEvent.setup();
    const mockOnModify = vi.fn();
    render(<OrderRow order={mockOrder} onModify={mockOnModify} />);

    const moreButton = screen.getByRole('button', { name: '' }).parentElement
      ?.querySelector('button:last-child');
    if (moreButton) {
      await user.click(moreButton);
      const modifyOption = await screen.findByText('Modify');
      await user.click(modifyOption);
      expect(mockOnModify).toHaveBeenCalled();
    }
  });

  it('should disable modify button when order is filled', () => {
    const filledOrder: Order = {
      ...mockOrder,
      status: 'filled',
      filled_quantity: 100,
    };
    render(<OrderRow order={filledOrder} onModify={vi.fn()} />);
    // Modify should not be available for filled orders
    expect(screen.getByText('Details')).toBeInTheDocument();
  });

  it('should color code buy/sell sides', () => {
    render(<OrderRow order={mockOrder} />);
    const buyText = screen.getByText('BUY');
    expect(buyText).toHaveClass('text-blue-600');

    const { unmount } = render(
      <OrderRow order={{ ...mockOrder, side: 'sell' }} />
    );
    const sellText = screen.getByText('SELL');
    expect(sellText).toHaveClass('text-orange-600');
    unmount();
  });

  it('should show realized P&L when available', () => {
    const orderWithPnL: Order = {
      ...mockOrder,
      realized_pnl: 150.50,
    };
    render(<OrderRow order={orderWithPnL} />);
    expect(screen.getByText('+$150.50')).toBeInTheDocument();
  });

  it('should show negative P&L in red', () => {
    const orderWithLoss: Order = {
      ...mockOrder,
      realized_pnl: -75.25,
    };
    render(<OrderRow order={orderWithLoss} />);
    const pnlText = screen.getByText('-$75.25');
    expect(pnlText).toHaveClass('text-red-600');
  });
});

// ============================================================================
// OrdersTable Tests
// ============================================================================

describe('OrdersTable', () => {
  const mockOrders: Order[] = [
    {
      id: 'order-1',
      symbol: 'EURUSD',
      type: 'market',
      side: 'buy',
      quantity: 100,
      filled_quantity: 100,
      price: 1.0850,
      status: 'filled',
      created_at: new Date('2025-11-14T10:00:00'),
      updated_at: new Date('2025-11-14T10:00:00'),
      commission: 10,
      realized_pnl: 50,
    },
    {
      id: 'order-2',
      symbol: 'GBPUSD',
      type: 'limit',
      side: 'sell',
      quantity: 200,
      filled_quantity: 0,
      limit_price: 1.2750,
      status: 'open',
      created_at: new Date('2025-11-14T11:00:00'),
      updated_at: new Date('2025-11-14T11:00:00'),
      commission: 0,
    },
    {
      id: 'order-3',
      symbol: 'USDJPY',
      type: 'stop',
      side: 'buy',
      quantity: 50,
      filled_quantity: 50,
      stop_price: 150.00,
      status: 'cancelled',
      created_at: new Date('2025-11-14T09:00:00'),
      updated_at: new Date('2025-11-14T09:30:00'),
      commission: 5,
    },
  ];

  it('should render orders table with all orders', () => {
    render(<OrdersTable orders={mockOrders} />);
    expect(screen.getByText('EURUSD')).toBeInTheDocument();
    expect(screen.getByText('GBPUSD')).toBeInTheDocument();
    expect(screen.getByText('USDJPY')).toBeInTheDocument();
  });

  it('should display table header with sortable columns', () => {
    render(<OrdersTable orders={mockOrders} />);
    expect(screen.getByText(/Order/)).toBeInTheDocument();
    expect(screen.getByText('Type')).toBeInTheDocument();
    expect(screen.getByText('Side')).toBeInTheDocument();
  });

  it('should show order statistics', () => {
    render(<OrdersTable orders={mockOrders} />);
    expect(screen.getByText(/Open:/)).toBeInTheDocument();
    expect(screen.getByText(/Filled:/)).toBeInTheDocument();
    expect(screen.getByText(/Cancelled:/)).toBeInTheDocument();
  });

  it('should filter orders by status', async () => {
    const user = userEvent.setup();
    render(<OrdersTable orders={mockOrders} />);

    const statusSelect = screen.getByDisplayValue('All Statuses');
    await user.click(statusSelect);
    const filledOption = await screen.findByText(/Filled/);
    await user.click(filledOption);

    // Should only show filled order
    expect(screen.getByText('EURUSD')).toBeInTheDocument();
    expect(screen.queryByText('GBPUSD')).not.toBeInTheDocument();
  });

  it('should filter orders by symbol search', async () => {
    const user = userEvent.setup();
    render(<OrdersTable orders={mockOrders} />);

    const searchInput = screen.getByPlaceholderText('Search by symbol...');
    await user.type(searchInput, 'EUR');

    // Should only show EURUSD order
    expect(screen.getByText('EURUSD')).toBeInTheDocument();
    expect(screen.queryByText('GBPUSD')).not.toBeInTheDocument();
    expect(screen.queryByText('USDJPY')).not.toBeInTheDocument();
  });

  it('should sort orders by different columns', async () => {
    const user = userEvent.setup();
    render(<OrdersTable orders={mockOrders} />);

    // Initial order should be by created_at (desc)
    const rows = screen.getAllByRole('button', { name: /Details/ });
    expect(rows.length).toBe(3);
  });

  it('should show loading state', () => {
    render(<OrdersTable orders={[]} isLoading={true} />);
    expect(screen.getByText('Loading orders...')).toBeInTheDocument();
  });

  it('should show empty state when no orders', () => {
    render(<OrdersTable orders={[]} />);
    expect(screen.getByText(/No orders yet/)).toBeInTheDocument();
  });

  it('should show error state', () => {
    const error = new Error('Failed to load orders');
    render(<OrdersTable orders={[]} error={error} />);
    expect(screen.getByText(/Error loading orders/)).toBeInTheDocument();
  });

  it('should call onModify callback', async () => {
    const user = userEvent.setup();
    const mockOnModify = vi.fn();
    render(<OrdersTable orders={mockOrders} onModify={mockOnModify} />);

    // This would require clicking the modify action
    // The actual implementation depends on how the dropdown is opened
  });

  it('should call onViewDetails callback', async () => {
    const user = userEvent.setup();
    const mockOnViewDetails = vi.fn();
    render(<OrdersTable orders={mockOrders} onViewDetails={mockOnViewDetails} />);

    const detailsButtons = screen.getAllByText('Details');
    if (detailsButtons.length > 0) {
      await user.click(detailsButtons[0]);
      // Callback would be called
    }
  });

  it('should calculate total P&L correctly', () => {
    render(<OrdersTable orders={mockOrders} />);
    expect(screen.getByText(/Total P&L:/)).toBeInTheDocument();
    // Order 1: +50, Order 3: 0 (cancelled) = 50 total
    expect(screen.getByText('+$50.00')).toBeInTheDocument();
  });

  it('should display summary statistics', () => {
    render(<OrdersTable orders={mockOrders} />);
    expect(screen.getByText(/Total Orders:/)).toBeInTheDocument();
    expect(screen.getByText(/Open Orders:/)).toBeInTheDocument();
    expect(screen.getByText(/Filled Orders:/)).toBeInTheDocument();
  });

  it('should handle responsive layout', () => {
    const { container } = render(<OrdersTable orders={mockOrders} />);
    // Check for responsive classes
    const tableHeader = container.querySelector('[class*="lg:grid"]');
    expect(tableHeader).toBeInTheDocument();
  });

  it('should show empty state message when no results after filtering', async () => {
    const user = userEvent.setup();
    render(<OrdersTable orders={mockOrders} />);

    const searchInput = screen.getByPlaceholderText('Search by symbol...');
    await user.type(searchInput, 'NONEXISTENT');

    expect(screen.getByText(/No orders match your filters/)).toBeInTheDocument();
  });

  it('should render order rows with proper data', () => {
    render(<OrdersTable orders={mockOrders} />);

    // Check that order details are visible
    mockOrders.forEach((order) => {
      expect(screen.getByText(order.symbol)).toBeInTheDocument();
    });
  });

  it('should update filters independently', async () => {
    const user = userEvent.setup();
    render(<OrdersTable orders={mockOrders} />);

    const searchInput = screen.getByPlaceholderText('Search by symbol...');
    await user.type(searchInput, 'USD');

    // Should now show GBPUSD and USDJPY (both contain USD)
    expect(screen.getByText('GBPUSD')).toBeInTheDocument();
    expect(screen.getByText('USDJPY')).toBeInTheDocument();
    expect(screen.queryByText('EURUSD')).not.toBeInTheDocument();
  });
});
