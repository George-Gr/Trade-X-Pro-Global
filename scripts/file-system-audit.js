#!/usr/bin/env node

/**
 * File System Audit and Cleanup Tool
 * Comprehensive file system analysis and cleanup for Trade-X-Pro-Global
 */

import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class FileSystemAudit {
    constructor(options = {}) {
        this.options = {
            rootPath: options.rootPath || process.cwd(),
            preview: options.preview || false,
            dryRun: options.dryRun || false,
            logRetentionDays: options.logRetentionDays || 30,
            protectSystemFiles: options.protectSystemFiles !== false,
            excludePatterns: new Set([
                '.git',
                'node_modules',
                'dist',
                'build',
                '.next',
                '.vscode',
                '.idea',
                '.DS_Store',
                'Thumbs.db'
            ]),
            ...options
        };

        this.stats = {
            totalFiles: 0,
            totalSize: 0,
            categories: {
                tempFiles: [],
                backupFiles: [],
                duplicateFiles: [],
                logFiles: [],
                orphanedFiles: [],
                installerFiles: [],
                corruptedFiles: [],
                testFiles: [],
                autoGeneratedFiles: [],
                largeFiles: []
            },
            duplicateGroups: new Map(),
            fileReferences: new Map(),
            protectedFiles: new Set()
        };

        this.unwantedExtensions = new Set([
            '.tmp', '.temp', '.cache', '.bak', '.backup', '.old',
            '.log', '.logs', '.pid', '.lock', '.swp', '.swo',
            '.orig', '.rej', '.diff', '.patch', '.bin', '.exe',
            '.msi', '.dmg', '.deb', '.rpm', '.pkg'
        ]);

        this.autoGeneratedPatterns = [
            /^generated\./,
            /^auto\./,
            /^build\./,
            /^dist\./,
            /\.min\.(js|css)$/,
            /\.bundle\.(js|css)$/,
            /^__pycache__$/,
            /\.pyc$/,
            /\.pyo$/,
            /\.class$/,
            /\.o$/,
            /\.so$/,
            /\.dylib$/
        ];
    }

    async audit() {
        console.log('üîç Starting File System Audit...');
        console.log(`üìÇ Root path: ${this.options.rootPath}`);
        console.log(`üëÅÔ∏è  Preview mode: ${this.options.preview}`);
        console.log(`üîÑ Dry run mode: ${this.options.dryRun}`);
        console.log('‚îÄ'.repeat(50));

        try {
            await this.scanDirectory(this.options.rootPath);
            await this.analyzeReferences();
            await this.findDuplicates();
            await this.categorizeFiles();
            await this.generateReport();
            
            if (!this.options.preview && !this.options.dryRun) {
                await this.performCleanup();
            }
            
            return this.stats;
        } catch (error) {
            console.error('‚ùå Audit failed:', error);
            throw error;
        }
    }

    async scanDirectory(dirPath, relativePath = '') {
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                const relativeFilePath = path.join(relativePath, entry.name);

                // Skip protected/system directories
                if (this.shouldSkipPath(relativeFilePath)) {
                    continue;
                }

                if (entry.isDirectory()) {
                    await this.scanDirectory(fullPath, relativeFilePath);
                } else if (entry.isFile()) {
                    await this.processFile(fullPath, relativeFilePath);
                }
            }
        } catch (error) {
            if (error.code !== 'ENOENT') {
                console.warn(`‚ö†Ô∏è  Could not read directory ${dirPath}: ${error.message}`);
            }
        }
    }

    async processFile(fullPath, relativePath) {
        try {
            const stats = await fs.stat(fullPath);
            
            if (!stats.isFile()) return;

            this.stats.totalFiles++;
            this.stats.totalSize += stats.size;

            const fileInfo = {
                path: relativePath,
                fullPath,
                size: stats.size,
                modified: stats.mtime,
                accessed: stats.atime,
                extension: path.extname(fullPath).toLowerCase(),
                isExecutable: (stats.mode & 0o111) !== 0,
                hash: null
            };

            // Calculate file hash for duplicate detection
            fileInfo.hash = await this.calculateFileHash(fullPath);
            
            // Store file reference
            if (!this.stats.fileReferences.has(relativePath)) {
                this.stats.fileReferences.set(relativePath, []);
            }
            this.stats.fileReferences.get(relativePath).push(fileInfo);

            // Check if file should be protected
            if (this.isProtectedFile(relativePath, fileInfo)) {
                this.stats.protectedFiles.add(relativePath);
                return;
            }

            await this.categorizeFile(fileInfo);

        } catch (error) {
            console.warn(`‚ö†Ô∏è  Could not process file ${fullPath}: ${error.message}`);
            
            // Add to corrupted files if we can't read it
            this.stats.categories.corruptedFiles.push({
                path: relativePath,
                fullPath,
                error: error.message,
                size: 0
            });
        }
    }

    shouldSkipPath(relativePath) {
        return Array.from(this.options.excludePatterns).some(pattern => {
            if (pattern.includes('*')) {
                const regex = new RegExp(pattern.replace(/\*/g, '.*'));
                return regex.test(relativePath);
            }
            return relativePath.includes(pattern);
        });
    }

    isProtectedFile(relativePath, fileInfo) {
        // Critical system and project files that should never be deleted
        const protectedPatterns = [
            /^package\.json$/,
            /^package-lock\.json$/,
            /^yarn\.lock$/,
            /^pnpm-lock\.yaml$/,
            /^tsconfig\.json$/,
            /^jsconfig\.json$/,
            /^vite\.config\.(js|ts)$/,
            /^webpack\.config\.(js|ts)$/,
            /^next\.config\.(js|ts)$/,
            /^tailwind\.config\.(js|ts)$/,
            /^postcss\.config\.js$/,
            /^eslint\.(config|rc)\.(js|json|yaml)$/,
            /^prettier\.(config|rc)\.(js|json|yaml)$/,
            /^tsconfig.*\.json$/,
            /^src\/.*\.(tsx?|jsx?)$/,
            /^src\/.*\.css$/,
            /^src\/.*\.scss$/,
            /^src\/.*\.sass$/,
            /^public\/.*$/,
            /^static\/.*$/,
            /^assets\/.*$/,
            /^components\/.*$/,
            /^pages\/.*$/,
            /^hooks\/.*$/,
            /^lib\/.*$/,
            /^utils\/.*$/,
            /^types\/.*$/,
            /^interfaces\/.*$/,
            /^constants\/.*$/,
            /^services\/.*$/,
            /^api\/.*$/,
            /^middleware\/.*$/,
            /^validators\/.*$/,
            /^schemas\/.*$/,
            /^models\/.*$/,
            /^controllers\/.*$/,
            /^routes\/.*$/,
            /^tests?\/.*$/,
            /^__tests__\/.*$/,
            /^e2e\/.*$/,
            /^coverage\/.*$/,
            /^docs\/.*\.(md|txt|rst)$/,
            /^README\.(md|txt|rst)$/,
            /^CHANGELOG\.(md|txt|rst)$/,
            /^LICENSE\.(txt|md)$/,
            /^CONTRIBUTING\.(md|txt|rst)$/,
            /^\.env(\..*)?$/,
            /^\.gitignore$/,
            /^\.dockerignore$/,
            /^\.editorconfig$/,
            /^\.gitattributes$/,
            /^\.prettierignore$/,
            /^\.eslintignore$/,
            /^\.vscode\/.*$/,
            /^\.idea\/.*$/,
            /^\.vs\/.*$/,
            /^\.settings\/.*$/,
            /^\.project$/,
            /^\.classpath$/,
            /^\.classpath$/,
            /^\.classpath$/,
            // Trading platform specific files
            /^\.roo\/.*$/,
            /^\.agent\/.*$/,
            /^\.husky\/.*$/,
            /^\.github\/.*$/,
            /^\.devcontainer\/.*$/,
            /^supabase\/.*$/,
            /^migrations\/.*$/,
            /^seeds\/.*$/,
            /^fixtures\/.*$/,
            /^scripts\/.*$/,
            /^archive\/.*$/,
            /^project_resources\/.*$/
        ];

        // Check if file matches any protected pattern
        const isProtected = protectedPatterns.some(pattern => {
            if (pattern instanceof RegExp) {
                return pattern.test(relativePath);
            }
            return relativePath === pattern;
        });

        // Protect critical file types
        const criticalExtensions = ['.json', '.js', '.ts', '.jsx', '.tsx', '.css', '.scss', '.sass'];
        const isCriticalType = criticalExtensions.includes(fileInfo.extension) && 
                              relativePath.includes('/src/') ||
                              relativePath.includes('/public/') ||
                              relativePath.includes('/assets/');

        return isProtected || isCriticalType;
    }

    async categorizeFile(fileInfo) {
        const { path: filePath, extension, size } = fileInfo;

        // Temporary files
        if (this.unwantedExtensions.has(extension) || 
            /\.(tmp|temp|cache|bak|backup|old|log|pid|lock|swp|swo|orig|rej)$/i.test(extension)) {
            this.stats.categories.tempFiles.push(fileInfo);
        }

        // Backup files
        if (filePath.includes('.backup') || 
            filePath.endsWith('~') || 
            /\.(bak|backup|old|orig|rej)$/i.test(extension)) {
            this.stats.categories.backupFiles.push(fileInfo);
        }

        // Log files beyond retention
        if (extension === '.log' || filePath.includes('.logs')) {
            const daysSinceModified = this.getDaysSinceDate(fileInfo.modified);
            if (daysSinceModified > this.options.logRetentionDays) {
                this.stats.categories.logFiles.push(fileInfo);
            }
        }

        // Large files (over 50MB)
        if (size > 50 * 1024 * 1024) {
            this.stats.categories.largeFiles.push(fileInfo);
        }

        // Installer/executable files
        if (fileInfo.isExecutable || 
            /\.(exe|msi|dmg|deb|rpm|pkg|app|bin)$/i.test(extension)) {
            this.stats.categories.installerFiles.push(fileInfo);
        }

        // Test files and development artifacts
        if (filePath.includes('/test') || 
            filePath.includes('/tests') || 
            filePath.includes('/__tests__') || 
            filePath.includes('/e2e') || 
            filePath.includes('.test.') || 
            filePath.includes('.spec.') ||
            filePath.includes('.test.tsx') ||
            filePath.includes('.test.ts') ||
            filePath.includes('.spec.tsx') ||
            filePath.includes('.spec.ts')) {
            this.stats.categories.testFiles.push(fileInfo);
        }

        // Auto-generated files
        if (this.isAutoGenerated(filePath)) {
            this.stats.categories.autoGeneratedFiles.push(fileInfo);
        }
    }

    isAutoGenerated(filePath) {
        return this.autoGeneratedPatterns.some(pattern => {
            if (pattern instanceof RegExp) {
                return pattern.test(filePath);
            }
            return filePath.includes(pattern);
        });
    }

    async calculateFileHash(filePath) {
        try {
            const data = await fs.readFile(filePath);
            return crypto.createHash('md5').update(data).digest('hex');
        } catch {
            return null;
        }
    }

    async analyzeReferences() {
        console.log('üîç Analyzing file references...');
        
        // Simple orphaned file detection - files not referenced in other files
        // This is a basic implementation and could be enhanced with proper AST parsing
        for (const [filePath, fileInfo] of this.stats.fileReferences) {
            // Skip files in certain directories that are likely to be orphaned
            if (filePath.includes('/temp/') || 
                filePath.includes('/tmp/') || 
                filePath.includes('/cache/') ||
                filePath.includes('/.cache/')) {
                this.stats.categories.orphanedFiles.push(...fileInfo);
            }
        }
    }

    async findDuplicates() {
        console.log('üîç Finding duplicate files...');
        
        const hashGroups = new Map();
        
        for (const [filePath, fileInfoList] of this.stats.fileReferences) {
            for (const fileInfo of fileInfoList) {
                if (!fileInfo.hash) continue;
                
                if (!hashGroups.has(fileInfo.hash)) {
                    hashGroups.set(fileInfo.hash, []);
                }
                hashGroups.get(fileInfo.hash).push(fileInfo);
            }
        }

        // Find groups with more than one file (duplicates)
        for (const [hash, files] of hashGroups) {
            if (files.length > 1) {
                const duplicateGroup = files.sort((a, b) => b.size - a.size); // Keep largest first
                this.stats.duplicateGroups.set(hash, duplicateGroup);
                
                // Add all but the first (largest) to duplicates list
                this.stats.categories.duplicateFiles.push(...duplicateGroup.slice(1));
            }
        }
    }

    async categorizeFiles() {
        console.log('üìä Categorizing files...');
        // Additional categorization logic can be added here
    }

    getDaysSinceDate(date) {
        const now = new Date();
        const diffTime = Math.abs(now - date);
        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    }

    async generateReport() {
        console.log('üìã Generating comprehensive report...');
        
        const report = {
            timestamp: new Date().toISOString(),
            summary: {
                totalFiles: this.stats.totalFiles,
                totalSize: this.formatBytes(this.stats.totalSize),
                totalSizeBytes: this.stats.totalSize,
                protectedFiles: this.stats.protectedFiles.size
            },
            categories: {},
            duplicateGroups: [],
            recommendations: []
        };

        // Process each category
        for (const [category, files] of Object.entries(this.stats.categories)) {
            if (files.length > 0) {
                const totalSize = files.reduce((sum, file) => sum + file.size, 0);
                report.categories[category] = {
                    count: files.length,
                    totalSize: this.formatBytes(totalSize),
                    totalSizeBytes: totalSize,
                    files: files.map(file => ({
                        path: file.path,
                        size: this.formatBytes(file.size),
                        sizeBytes: file.size,
                        modified: file.modified.toISOString(),
                        accessed: file.accessed?.toISOString(),
                        extension: file.extension
                    }))
                };
            }
        }

        // Process duplicate groups
        for (const [hash, files] of this.stats.duplicateGroups) {
            report.duplicateGroups.push({
                hash,
                count: files.length,
                totalSize: this.formatBytes(files.reduce((sum, file) => sum + file.size, 0)),
                files: files.map(file => ({
                    path: file.path,
                    size: this.formatBytes(file.size)
                }))
            });
        }

        // Generate recommendations
        this.generateRecommendations(report);

        // Save report
        const reportPath = path.join(this.options.rootPath, 'FILE_SYSTEM_AUDIT_REPORT.json');
        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));

        // Save readable report
        await this.generateReadableReport(report);

        console.log(`üìÑ Report saved to: ${reportPath}`);
        return report;
    }

    generateRecommendations(report) {
        const recommendations = [];

        // Temporary files
        if (report.categories.tempFiles?.count > 0) {
            recommendations.push({
                type: 'tempFiles',
                priority: 'high',
                action: 'Delete',
                description: `Remove ${report.categories.tempFiles.count} temporary files (${report.categories.tempFiles.totalSize})`,
                files: report.categories.tempFiles.files.slice(0, 10) // Show first 10
            });
        }

        // Backup files
        if (report.categories.backupFiles?.count > 0) {
            recommendations.push({
                type: 'backupFiles',
                priority: 'medium',
                action: 'Delete',
                description: `Remove ${report.categories.backupFiles.count} backup files (${report.categories.backupFiles.totalSize})`,
                files: report.categories.backupFiles.files.slice(0, 10)
            });
        }

        // Duplicate files
        if (report.categories.duplicateFiles?.length > 0) {
            recommendations.push({
                type: 'duplicateFiles',
                priority: 'high',
                action: 'Remove Duplicates',
                description: `Remove ${report.categories.duplicateFiles.length} duplicate files`,
                groups: report.duplicateGroups.slice(0, 5) // Show first 5 groups
            });
        }

        // Old log files
        if (report.categories.logFiles?.count > 0) {
            recommendations.push({
                type: 'logFiles',
                priority: 'medium',
                action: 'Archive/Delete',
                description: `Remove ${report.categories.logFiles.count} old log files (${report.categories.logFiles.totalSize})`,
                files: report.categories.logFiles.files.slice(0, 10)
            });
        }

        // Large files
        if (report.categories.largeFiles?.count > 0) {
            recommendations.push({
                type: 'largeFiles',
                priority: 'low',
                action: 'Review',
                description: `Review ${report.categories.largeFiles.count} large files (${report.categories.largeFiles.totalSize})`,
                files: report.categories.largeFiles.files.slice(0, 10)
            });
        }

        // Test files
        if (report.categories.testFiles?.count > 0) {
            recommendations.push({
                type: 'testFiles',
                priority: 'low',
                action: 'Archive',
                description: `Consider archiving ${report.categories.testFiles.count} test files`,
                files: report.categories.testFiles.files.slice(0, 10)
            });
        }

        report.recommendations = recommendations;
    }

    async generateReadableReport(report) {
        let markdown = `# File System Audit Report\n\n`;
        markdown += `**Generated:** ${report.timestamp}\n`;
        markdown += `**Total Files:** ${report.summary.totalFiles}\n`;
        markdown += `**Total Size:** ${report.summary.totalSize}\n`;
        markdown += `**Protected Files:** ${report.summary.protectedFiles}\n\n`;

        markdown += `## Summary by Category\n\n`;
        markdown += `| Category | Count | Total Size |\n`;
        markdown += `|----------|-------|------------|\n`;

        for (const [category, data] of Object.entries(report.categories)) {
            if (data.count > 0) {
                const categoryName = category.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                markdown += `| ${categoryName} | ${data.count} | ${data.totalSize} |\n`;
            }
        }

        markdown += `\n## Recommendations\n\n`;

        for (const rec of report.recommendations) {
            markdown += `### ${rec.type.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}\n`;
            markdown += `**Priority:** ${rec.priority}\n`;
            markdown += `**Action:** ${rec.action}\n`;
            markdown += `**Description:** ${rec.description}\n\n`;

            if (rec.files) {
                markdown += `**Files to process:**\n`;
                for (const file of rec.files) {
                    markdown += `- \`${file.path}\` (${file.size})\n`;
                }
                markdown += `\n`;
            }

            if (rec.groups) {
                markdown += `**Duplicate groups:**\n`;
                for (const group of rec.groups) {
                    markdown += `- Group ${group.hash.substring(0, 8)}... (${group.count} files, ${group.totalSize})\n`;
                }
                markdown += `\n`;
            }
        }

        const readableReportPath = path.join(this.options.rootPath, 'FILE_SYSTEM_AUDIT_READABLE.md');
        await fs.writeFile(readableReportPath, markdown);
        console.log(`üìÑ Readable report saved to: ${readableReportPath}`);
    }

    async performCleanup() {
        console.log('üßπ Starting cleanup operations...');
        
        const cleanupResults = {
            deleted: [],
            failed: [],
            protected: []
        };

        // Process each category for cleanup
        for (const [category, files] of Object.entries(this.stats.categories)) {
            console.log(`Processing ${category}: ${files.length} files`);
            
            for (const file of files) {
                try {
                    if (this.stats.protectedFiles.has(file.path)) {
                        cleanupResults.protected.push(file.path);
                        continue;
                    }

                    if (this.options.dryRun) {
                        console.log(`[DRY RUN] Would delete: ${file.path}`);
                        cleanupResults.deleted.push({
                            ...file,
                            action: 'would_delete'
                        });
                    } else if (this.options.preview) {
                        console.log(`[PREVIEW] Ready to delete: ${file.path}`);
                        cleanupResults.deleted.push({
                            ...file,
                            action: 'preview_only'
                        });
                    } else {
                        await this.secureDelete(file.fullPath);
                        console.log(`‚úÖ Deleted: ${file.path}`);
                        cleanupResults.deleted.push({
                            ...file,
                            action: 'deleted'
                        });
                    }
                } catch (error) {
                    console.error(`‚ùå Failed to delete ${file.path}: ${error.message}`);
                    cleanupResults.failed.push({
                        path: file.path,
                        error: error.message
                    });
                }
            }
        }

        // Save cleanup results
        const cleanupPath = path.join(this.options.rootPath, 'CLEANUP_RESULTS.json');
        await fs.writeFile(cleanupPath, JSON.stringify(cleanupResults, null, 2));
        console.log(`üìä Cleanup results saved to: ${cleanupPath}`);

        return cleanupResults;
    }

    async secureDelete(filePath) {
        // Simple secure delete - overwrite with random data then delete
        try {
            const stats = await fs.stat(filePath);
            const fd = await fs.open(filePath, 'r+');
            
            // Overwrite with random data
            const buffer = Buffer.alloc(4096);
            for (let i = 0; i < Math.ceil(stats.size / buffer.length); i++) {
                crypto.randomFillSync(buffer);
                await fs.write(fd, buffer, 0, buffer.length, i * buffer.length);
            }
            
            await fs.close(fd);
            await fs.unlink(filePath);
        } catch (error) {
            // Fallback to regular delete
            await fs.unlink(filePath);
        }
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
    const args = process.argv.slice(2);
    const options = {
        rootPath: args[0] || process.cwd(),
        preview: args.includes('--preview'),
        dryRun: args.includes('--dry-run'),
        logRetentionDays: parseInt(args.find(arg => arg.startsWith('--log-retention='))?.split('=')[1] || '30'),
        protectSystemFiles: !args.includes('--no-protect')
    };

    const audit = new FileSystemAudit(options);
    audit.audit().then(() => {
        console.log('‚úÖ File system audit completed successfully!');
        process.exit(0);
    }).catch(error => {
        console.error('‚ùå File system audit failed:', error);
        process.exit(1);
    });
}

export default FileSystemAudit;