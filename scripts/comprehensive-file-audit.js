#!/usr/bin/env node

/**
 * Comprehensive File System Audit and Cleanup System
 * Master integration of all audit and cleanup tools
 */

import fs from 'fs/promises';
import path from 'path';
import FileSystemAudit from './file-system-audit.js';
import FileReferenceAnalyzer from './file-reference-analyzer.js';
import AdvancedDuplicateDetector from './advanced-duplicate-detector.js';
import FileIntegrityChecker from './file-integrity-checker.js';
import SecureDeletion from './secure-deletion.js';

class ComprehensiveFileAudit {
    constructor(options = {}) {
        this.options = {
            rootPath: options.rootPath || process.cwd(),
            enableReferenceAnalysis: options.enableReferenceAnalysis !== false,
            enableDuplicateDetection: options.enableDuplicateDetection !== false,
            enableIntegrityChecking: options.enableIntegrityChecking !== false,
            enableSecureDeletion: options.enableSecureDeletion !== false,
            generateReports: options.generateReports !== false,
            outputDir: options.outputDir || 'audit-reports',
            ...options
        };

        this.results = {
            timestamp: new Date().toISOString(),
            system: {
                totalFiles: 0,
                totalSize: 0,
                scanDuration: 0
            },
            categories: {
                tempFiles: [],
                backupFiles: [],
                duplicateFiles: [],
                orphanedFiles: [],
                logFiles: [],
                installerFiles: [],
                corruptedFiles: [],
                testFiles: [],
                autoGeneratedFiles: [],
                largeFiles: [],
                integrityIssues: [],
                permissionIssues: []
            },
            duplicateGroups: [],
            integrityReport: null,
            deletionResults: null,
            recommendations: [],
            summary: {
                potentialSavings: 0,
                filesToDelete: 0,
                criticalIssues: 0,
                securityRisks: 0
            }
        };
    }

    async runFullAudit() {
        console.log('üöÄ Starting Comprehensive File System Audit...');
        console.log(`üìÇ Root Path: ${this.options.rootPath}`);
        console.log(`üîß Features: Reference Analysis, Duplicate Detection, Integrity Checking, Secure Deletion`);
        console.log('=' .repeat(70));

        const startTime = Date.now();

        try {
            // Step 1: Basic File System Audit
            await this.runBasicAudit();

            // Step 2: Advanced Analysis
            if (this.options.enableReferenceAnalysis) {
                await this.runReferenceAnalysis();
            }

            if (this.options.enableDuplicateDetection) {
                await this.runDuplicateDetection();
            }

            if (this.options.enableIntegrityChecking) {
                await this.runIntegrityChecking();
            }

            // Step 3: Generate Comprehensive Report
            await this.generateComprehensiveReport();

            // Step 4: Cleanup (if requested)
            if (!this.options.preview && !this.options.dryRun) {
                await this.performCleanup();
            }

            this.results.system.scanDuration = Date.now() - startTime;
            
            console.log('\n‚úÖ Comprehensive File Audit Completed!');
            console.log(`‚è±Ô∏è  Total Duration: ${(this.results.system.scanDuration / 1000).toFixed(2)}s`);
            
            return this.results;

        } catch (error) {
            console.error('‚ùå Comprehensive audit failed:', error);
            throw error;
        }
    }

    async runBasicAudit() {
        console.log('\nüìã Step 1: Basic File System Audit...');
        
        const audit = new FileSystemAudit({
            rootPath: this.options.rootPath,
            preview: this.options.preview,
            dryRun: this.options.dryRun,
            logRetentionDays: this.options.logRetentionDays,
            protectSystemFiles: this.options.protectSystemFiles
        });

        const basicResults = await audit.audit();
        
        // Merge results
        this.results.system.totalFiles = basicResults.summary?.totalFiles || 0;
        this.results.system.totalSize = basicResults.summary?.totalSizeBytes || 0;
        
        for (const [category, data] of Object.entries(basicResults.categories)) {
            if (data) {
                this.results.categories[category] = data;
            }
        }
        
        this.results.duplicateGroups = basicResults.duplicateGroups || [];
        this.results.recommendations.push(...basicResults.recommendations || []);
    }

    async runReferenceAnalysis() {
        console.log('\nüîç Step 2A: Reference Analysis...');
        
        const analyzer = new FileReferenceAnalyzer(this.options.rootPath);
        const referenceResults = await analyzer.analyze();
        
        // Add orphaned files from reference analysis
        if (referenceResults.orphanedFiles.length > 0) {
            this.results.categories.orphanedFiles = referenceResults.orphanedFiles.map(file => ({
                path: file,
                fullPath: path.join(this.options.rootPath, file),
                reason: 'no_references'
            }));
        }
        
        // Add recommendations from reference analysis
        this.results.recommendations.push(...referenceResults.recommendations || []);
    }

    async runDuplicateDetection() {
        console.log('\nüîç Step 2B: Duplicate Detection...');
        
        const detector = new AdvancedDuplicateDetector({
            minFileSize: 1024,
            similarityThreshold: 0.95,
            maxFileSizeForHashing: 50 * 1024 * 1024
        });

        const duplicateResults = await detector.findDuplicates(this.options.rootPath);
        
        // Update duplicate information
        this.results.duplicateGroups = duplicateResults.duplicateGroups || [];
        this.results.categories.duplicateFiles = duplicateResults.duplicateGroups
            ? duplicateResults.duplicateGroups.flatMap(group => group.duplicates || [])
            : [];
        
        // Add duplicate recommendations
        this.results.recommendations.push(...duplicateResults.recommendations || []);
    }

    async runIntegrityChecking() {
        console.log('\nüîç Step 2C: Integrity Checking...');
        
        const checker = new FileIntegrityChecker({
            checkCompression: true,
            checkEncoding: true,
            maxCorruptedFiles: 1000
        });

        const integrityResults = await checker.checkFileIntegrity(this.options.rootPath);
        this.results.integrityReport = integrityResults;
        
        // Merge integrity issues into categories
        this.results.categories.corruptedFiles.push(...(integrityResults.issues.corrupted || []));
        this.results.categories.integrityIssues.push(...(integrityResults.issues.corrupted || []));
        
        if (integrityResults.issues.permission) {
            this.results.categories.permissionIssues = integrityResults.issues.permission;
        }
        
        // Add integrity recommendations
        this.results.recommendations.push(...integrityResults.recommendations || []);
    }

    async generateComprehensiveReport() {
        console.log('\nüìä Step 3: Generating Comprehensive Report...');
        
        // Calculate summary statistics
        this.calculateSummaryStatistics();
        
        // Generate comprehensive report
        const report = {
            ...this.results,
            auditConfig: {
                rootPath: this.options.rootPath,
                features: {
                    referenceAnalysis: this.options.enableReferenceAnalysis,
                    duplicateDetection: this.options.enableDuplicateDetection,
                    integrityChecking: this.options.enableIntegrityChecking,
                    secureDeletion: this.options.enableSecureDeletion
                },
                timestamp: new Date().toISOString()
            }
        };

        // Save JSON report
        if (this.options.generateReports) {
            await this.saveReport('COMPREHENSIVE_AUDIT_REPORT.json', report);
            await this.generateReadableReport(report);
        }

        // Display summary
        this.displaySummary();
    }

    calculateSummaryStatistics() {
        let totalFilesToDelete = 0;
        let totalPotentialSavings = 0;
        let criticalIssues = 0;
        let securityRisks = 0;

        for (const [category, files] of Object.entries(this.results.categories)) {
            if (files && files.length > 0) {
                totalFilesToDelete += files.length;
                
                // Calculate potential savings
                if (['tempFiles', 'backupFiles', 'duplicateFiles', 'logFiles'].includes(category)) {
                    const categorySavings = files.reduce((sum, file) => sum + (file.size || 0), 0);
                    totalPotentialSavings += categorySavings;
                }
                
                // Count critical issues
                if (category === 'corruptedFiles') {
                    criticalIssues += files.length;
                }
                
                // Count security risks
                if (category === 'permissionIssues') {
                    securityRisks += files.length;
                }
            }
        }

        this.results.summary = {
            potentialSavings: totalPotentialSavings,
            filesToDelete: totalFilesToDelete,
            criticalIssues: criticalIssues,
            securityRisks: securityRisks
        };
    }

    async performCleanup() {
        console.log('\nüßπ Step 4: Performing Cleanup...');
        
        if (!this.options.enableSecureDeletion) {
            console.log('‚ö†Ô∏è  Secure deletion disabled, skipping cleanup');
            return;
        }

        // Collect files to delete
        const filesToDelete = [];
        
        for (const [category, files] of Object.entries(this.results.categories)) {
            if (files && files.length > 0) {
                // Only delete safe categories
                if (['tempFiles', 'backupFiles', 'duplicateFiles', 'logFiles'].includes(category)) {
                    files.forEach(file => {
                        if (file.fullPath) {
                            filesToDelete.push(file.fullPath);
                        }
                    });
                }
            }
        }

        if (filesToDelete.length === 0) {
            console.log('‚ÑπÔ∏è  No files selected for deletion');
            return;
        }

        console.log(`üóëÔ∏è  Deleting ${filesToDelete.length} files securely...`);

        const deleter = new SecureDeletion({
            method: 'nist',
            passes: 3,
            verifyDeletion: true,
            backupMetadata: true
        });

        const deletionResults = await deleter.secureDelete(filesToDelete);
        this.results.deletionResults = deletionResults;
    }

    async saveReport(filename, report) {
        // Ensure output directory exists
        await fs.mkdir(this.options.outputDir, { recursive: true });
        
        const reportPath = path.join(this.options.outputDir, filename);
        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
        
        console.log(`üìÑ Report saved: ${reportPath}`);
    }

    async generateReadableReport(report) {
        let markdown = `# Comprehensive File System Audit Report\n\n`;
        markdown += `**Generated:** ${report.timestamp}\n`;
        markdown += `**Duration:** ${(report.system.scanDuration / 1000).toFixed(2)}s\n`;
        markdown += `**Root Path:** ${report.auditConfig.rootPath}\n\n`;

        markdown += `## Executive Summary\n\n`;
        markdown += `- **Total Files Scanned:** ${report.system.totalFiles}\n`;
        markdown += `- **Total Size:** ${this.formatBytes(report.system.totalSize)}\n`;
        markdown += `- **Files to Delete:** ${report.summary.filesToDelete}\n`;
        markdown += `- **Potential Savings:** ${this.formatBytes(report.summary.potentialSavings)}\n`;
        markdown += `- **Critical Issues:** ${report.summary.criticalIssues}\n`;
        markdown += `- **Security Risks:** ${report.summary.securityRisks}\n\n`;

        markdown += `## Files by Category\n\n`;
        markdown += `| Category | Count | Potential Action |\n`;
        markdown += `|----------|-------|------------------|\n`;

        for (const [category, files] of Object.entries(report.categories)) {
            if (files && files.length > 0) {
                const categoryName = category.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                const action = this.getCategoryAction(category);
                markdown += `| ${categoryName} | ${files.length} | ${action} |\n`;
            }
        }

        if (report.duplicateGroups.length > 0) {
            markdown += `\n## Duplicate File Groups\n\n`;
            markdown += `Found ${report.duplicateGroups.length} groups of duplicate files.\n\n`;
            
            for (const group of report.duplicateGroups.slice(0, 5)) {
                markdown += `### Group ${group.id}\n`;
                markdown += `- **Files:** ${group.fileCount}\n`;
                markdown += `- **Total Size:** ${this.formatBytes(group.totalSize)}\n`;
                markdown += `- **Duplicates to Remove:** ${group.duplicates.length}\n\n`;
            }
        }

        if (report.recommendations.length > 0) {
            markdown += `## Recommendations\n\n`;
            
            for (const rec of report.recommendations) {
                const priorityIcon = this.getPriorityIcon(rec.priority);
                markdown += `${priorityIcon} **${rec.type.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}**\n`;
                markdown += `*${rec.description}*\n\n`;
            }
        }

        if (report.integrityReport && report.integrityReport.issues) {
            markdown += `## File Integrity Issues\n\n`;
            
            for (const [issueType, issues] of Object.entries(report.integrityReport.issues)) {
                if (issues.length > 0) {
                    markdown += `### ${issueType.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}\n`;
                    markdown += `Found ${issues.length} issues.\n\n`;
                }
            }
        }

        const readablePath = path.join(this.options.outputDir, 'COMPREHENSIVE_AUDIT_READABLE.md');
        await fs.writeFile(readablePath, markdown);
        console.log(`üìÑ Readable report saved: ${readablePath}`);
    }

    getCategoryAction(category) {
        const actions = {
            tempFiles: 'Delete',
            backupFiles: 'Remove',
            duplicateFiles: 'Deduplicate',
            orphanedFiles: 'Review',
            logFiles: 'Archive/Delete',
            installerFiles: 'Remove if unused',
            corruptedFiles: 'Restore/Delete',
            testFiles: 'Archive',
            autoGeneratedFiles: 'Regenerate',
            largeFiles: 'Optimize',
            integrityIssues: 'Fix',
            permissionIssues: 'Correct'
        };
        return actions[category] || 'Review';
    }

    getPriorityIcon(priority) {
        switch (priority) {
            case 'critical': return 'üî¥';
            case 'high': return 'üü†';
            case 'medium': return 'üü°';
            case 'low': return 'üü¢';
            default: return '‚ö™';
        }
    }

    displaySummary() {
        console.log('\nüìä COMPREHENSIVE AUDIT SUMMARY');
        console.log('=' .repeat(50));
        console.log(`Total Files: ${this.results.system.totalFiles}`);
        console.log(`Total Size: ${this.formatBytes(this.results.system.totalSize)}`);
        console.log(`Files to Delete: ${this.results.summary.filesToDelete}`);
        console.log(`Potential Savings: ${this.formatBytes(this.results.summary.potentialSavings)}`);
        console.log(`Critical Issues: ${this.results.summary.criticalIssues}`);
        console.log(`Security Risks: ${this.results.summary.securityRisks}`);

        console.log('\nüìÅ FILES BY CATEGORY:');
        console.log('‚îÄ'.repeat(30));
        
        for (const [category, files] of Object.entries(this.results.categories)) {
            if (files && files.length > 0) {
                const categoryName = category.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                console.log(`${categoryName.padEnd(20)} ${files.length.toString().padStart(4)} files`);
            }
        }

        if (this.results.duplicateGroups.length > 0) {
            console.log('\nüîç DUPLICATES:');
            console.log('‚îÄ'.repeat(30));
            console.log(`${this.results.duplicateGroups.length} duplicate groups found`);
        }

        console.log('\nüí° TOP RECOMMENDATIONS:');
        console.log('‚îÄ'.repeat(30));
        this.results.recommendations.slice(0, 5).forEach((rec, i) => {
            const icon = this.getPriorityIcon(rec.priority);
            console.log(`${i + 1}. ${icon} ${rec.type.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}`);
            console.log(`   ${rec.description}`);
        });
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
    const args = process.argv.slice(2);
    
    const options = {
        rootPath: args[0] || process.cwd(),
        preview: args.includes('--preview'),
        dryRun: args.includes('--dry-run'),
        enableReferenceAnalysis: !args.includes('--no-ref-analysis'),
        enableDuplicateDetection: !args.includes('--no-duplicates'),
        enableIntegrityChecking: !args.includes('--no-integrity'),
        enableSecureDeletion: !args.includes('--no-secure-delete'),
        generateReports: !args.includes('--no-reports'),
        outputDir: args.find(arg => arg.startsWith('--output='))?.split('=')[1] || 'audit-reports',
        logRetentionDays: parseInt(args.find(arg => arg.startsWith('--log-retention='))?.split('=')[1] || '30'),
        protectSystemFiles: !args.includes('--no-protect')
    };

    const audit = new ComprehensiveFileAudit(options);
    audit.runFullAudit().then(() => {
        console.log('\n‚úÖ Comprehensive audit completed successfully!');
        process.exit(0);
    }).catch(error => {
        console.error('‚ùå Comprehensive audit failed:', error);
        process.exit(1);
    });
}

export default ComprehensiveFileAudit;